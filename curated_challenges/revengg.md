# JoyDivision
First i decompile it
```
/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
void sub_1030();
void sub_1040();
void sub_1050();
void sub_1060();
void sub_1070();
void sub_1080();
void sub_1090();
void sub_10A0();
void sub_10B0();
void sub_10C0();
void sub_10D0();
void sub_10E0();
void sub_10F0();
void sub_1100();
void sub_1110();
// int _cxa_finalize(void *);
// int putchar(int c);
// int puts(const char *s);
// int fclose(FILE *stream);
// int printf(const char *format, ...);
// char *fgets(char *s, int n, FILE *stream);
// __int64 ftell(FILE *stream);
// void *malloc(size_t size);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ptrace(enum __ptrace_request request, ...);
// int mprotect(void *addr, size_t len, int prot);
// FILE *fopen(const char *filename, const char *modes);
// __int64 sysconf(int name);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
char *deregister_tm_clones();
__int64 register_tm_clones();
char *_do_global_dtors_aux();
__int64 frame_dummy(); // weak
__int64 __fastcall rotate_block_left(__int64 a1, int a2, int a3);
__int64 __fastcall rotate_block_right(__int64 a1, int a2, int a3);
__int64 anti_debug();
__int64 __fastcall flipBits(__int64 a1, int a2);
__int64 __fastcall doWeirdStuff(__int64 a1, int a2);
_BYTE *__fastcall expand(__int64 a1, int a2);
char *teehee();
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_16D3; // weak
_BYTE SBOX[256] =
{
  99,
  124,
  119,
  123,
  -14,
  107,
  111,
  -59,
  48,
  1,
  103,
  43,
  -2,
  -41,
  -85,
  118,
  -54,
  -126,
  -55,
  125,
  -6,
  89,
  71,
  -16,
  -83,
  -44,
  -94,
  -81,
  -100,
  -92,
  114,
  -64,
  -73,
  -3,
  -109,
  38,
  54,
  63,
  -9,
  -52,
  52,
  -91,
  -27,
  -15,
  113,
  -40,
  49,
  21,
  4,
  -57,
  35,
  -61,
  24,
  -106,
  5,
  -102,
  7,
  18,
  128,
  -30,
  -21,
  39,
  -78,
  117,
  9,
  -125,
  44,
  26,
  27,
  110,
  90,
  -96,
  82,
  59,
  -42,
  -77,
  41,
  -29,
  47,
  -124,
  83,
  -47,
  0,
  -19,
  32,
  -4,
  -79,
  91,
  106,
  -53,
  -66,
  57,
  74,
  76,
  88,
  -49,
  -48,
  -17,
  -86,
  -5,
  67,
  77,
  51,
  -123,
  69,
  -7,
  2,
  127,
  80,
  60,
  -97,
  -88,
  81,
  -93,
  64,
  -113,
  -110,
  -99,
  56,
  -11,
  -68,
  -74,
  -38,
  33,
  16,
  -1,
  -13,
  -46,
  -51,
  12,
  19,
  -20,
  95,
  -105,
  68,
  23,
  -60,
  -89,
  126,
  61,
  100,
  93,
  25,
  115,
  96,
  -127,
  79,
  -36,
  34,
  42,
  -112,
  -120,
  70,
  -18,
  -72,
  20,
  -34,
  94,
  11,
  -37,
  -32,
  50,
  58,
  10,
  73,
  6,
  36,
  92,
  -62,
  -45,
  -84,
  98,
  -111,
  -107,
  -28,
  121,
  -25,
  -56,
  55,
  109,
  -115,
  -43,
  78,
  -87,
  108,
  86,
  -12,
  -22,
  101,
  122,
  -82,
  8,
  -70,
  120,
  37,
  46,
  28,
  -90,
  -76,
  -58,
  -24,
  -35,
  116,
  31,
  75,
  -67,
  -117,
  -118,
  112,
  62,
  -75,
  102,
  72,
  3,
  -10,
  14,
  97,
  53,
  87,
  -71,
  -122,
  -63,
  29,
  -98,
  -31,
  -8,
  -104,
  17,
  105,
  -39,
  -114,
  -108,
  -101,
  30,
  -121,
  -23,
  -50,
  85,
  40,
  -33,
  -116,
  -95,
  -119,
  13,
  -65,
  -26,
  66,
  104,
  65,
  -103,
  45,
  15,
  -80,
  84,
  -69,
  22
}; // weak
void *_dso_handle = &_dso_handle; // idb
char _TMC_END__; // weak


//----- (0000000000001000) ----------------------------------------------------
// Alternative name is '_init'
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 40B0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030()
{
  sub_1020();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040()
{
  sub_1020();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050()
{
  sub_1020();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060()
{
  sub_1020();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070()
{
  sub_1020();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080()
{
  sub_1020();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090()
{
  sub_1020();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0()
{
  sub_1020();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0()
{
  sub_1020();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0()
{
  sub_1020();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0()
{
  sub_1020();
}

//----- (00000000000010E0) ----------------------------------------------------
void sub_10E0()
{
  sub_1020();
}

//----- (00000000000010F0) ----------------------------------------------------
void sub_10F0()
{
  sub_1020();
}

//----- (0000000000001100) ----------------------------------------------------
void sub_1100()
{
  sub_1020();
}

//----- (0000000000001110) ----------------------------------------------------
void sub_1110()
{
  sub_1020();
}

//----- (0000000000001220) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 122A: positive sp value 8 has been found
// 1231: variable 'v3' is possibly undefined

//----- (0000000000001250) ----------------------------------------------------
char *deregister_tm_clones()
{
  return &_TMC_END__;
}
// 4010: using guessed type char _TMC_END__;

//----- (0000000000001280) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0;
}

//----- (00000000000012C0) ----------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // rax

  if ( !_TMC_END__ )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    _TMC_END__ = 1;
  }
  return result;
}
// 4010: using guessed type char _TMC_END__;

//----- (0000000000001300) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 1300: using guessed type __int64 frame_dummy();

//----- (0000000000001309) ----------------------------------------------------
__int64 __fastcall rotate_block_left(__int64 a1, int a2, int a3)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-14h]
  unsigned int j; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  if ( a3 && a2 )
  {
    v6 = 0;
    for ( i = 0; i < a2; ++i )
      v6 |= (unsigned __int64)*(unsigned __int8 *)(i + a1) << (8 * (unsigned __int8)i);
    v7 = (((~(-1LL << (8 * (unsigned __int8)a2)) & v6) >> (8 * (unsigned __int8)a2 - a3))
        | ((~(-1LL << (8 * (unsigned __int8)a2)) & v6) << a3))
       & ~(-1LL << (8 * (unsigned __int8)a2));
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( (int)j >= a2 )
        break;
      *(_BYTE *)((int)j + a1) = v7 >> (8 * (unsigned __int8)j);
    }
  }
  return result;
}

//----- (0000000000001413) ----------------------------------------------------
__int64 __fastcall rotate_block_right(__int64 a1, int a2, int a3)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-14h]
  unsigned int j; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  if ( a3 && a2 )
  {
    v6 = 0;
    for ( i = 0; i < a2; ++i )
      v6 |= (unsigned __int64)*(unsigned __int8 *)(i + a1) << (8 * (unsigned __int8)i);
    v7 = (((~(-1LL << (8 * (unsigned __int8)a2)) & v6) << (8 * (unsigned __int8)a2 - a3))
        | ((~(-1LL << (8 * (unsigned __int8)a2)) & v6) >> a3))
       & ~(-1LL << (8 * (unsigned __int8)a2));
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( (int)j >= a2 )
        break;
      *(_BYTE *)((int)j + a1) = v7 >> (8 * (unsigned __int8)j);
    }
  }
  return result;
}

//----- (000000000000151D) ----------------------------------------------------
__int64 anti_debug()
{
  __int64 result; // rax

  result = ptrace(PTRACE_TRACEME, 0, 1, 0);
  if ( result == -1 )
  {
    puts("THOU SHALL NOT READ MY MIND WITH GOTHIC MAGIC CAESER!!!\n");
    exit(1);
  }
  return result;
}

//----- (0000000000001565) ----------------------------------------------------
__int64 __fastcall flipBits(__int64 a1, int a2)
{
  __int64 result; // rax
  char v3; // [rsp+13h] [rbp-9h]
  _BOOL4 v4; // [rsp+14h] [rbp-8h]
  unsigned int i; // [rsp+18h] [rbp-4h]

  v4 = 0;
  v3 = 105;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i >= a2 )
      break;
    if ( v4 )
    {
      *(_BYTE *)((int)i + a1) ^= v3;
      v3 += 32;
    }
    else
    {
      *(_BYTE *)((int)i + a1) = ~*(_BYTE *)((int)i + a1);
    }
    v4 = !v4;
  }
  return result;
}

//----- (00000000000015F4) ----------------------------------------------------
__int64 __fastcall doWeirdStuff(__int64 a1, int a2)
{
  int v2; // eax
  __int64 result; // rax
  unsigned int i; // [rsp+14h] [rbp-1Ch]
  int j; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  for ( i = 0; ; i += 5 )
  {
    result = i;
    if ( (int)i >= a2 )
      break;
    v2 = a2 - i;
    if ( (int)(a2 - i) >= 5 )
      v2 = 5;
    v6 = (int)i + a1;
    for ( j = 0; j < v2; ++j )
      *(_BYTE *)(j + v6) = SBOX[j ^ *(unsigned __int8 *)(j + v6)];
    rotate_block_left(v6, v2, 3 * v2);
  }
  return result;
}
// 2020: using guessed type _BYTE SBOX[256];

//----- (00000000000016B9) ----------------------------------------------------
_BYTE *__fastcall expand(__int64 a1, int a2)
{
  unsigned __int8 v3; // [rsp+1Bh] [rbp-15h]
  _BOOL4 v4; // [rsp+1Ch] [rbp-14h]
  int i; // [rsp+20h] [rbp-10h]
  _BYTE *v6; // [rsp+28h] [rbp-8h]

  v4 = 0;
  v3 = 105;
  v6 = malloc(2 * a2);
  for ( i = 0; i < a2; ++i )
  {
    if ( v4 )
    {
      v6[2 * i] = (v3 >> 4) | *(_BYTE *)(i + a1) & 0xF0;
      v6[2 * i + 1] = (16 * v3) | *(_BYTE *)(i + a1) & 0xF;
    }
    else
    {
      v6[2 * i] = (16 * v3) | *(_BYTE *)(i + a1) & 0xF;
      v6[2 * i + 1] = (v3 >> 4) | *(_BYTE *)(i + a1) & 0xF0;
    }
    v3 *= 11;
    v4 = !v4;
  }
  printf("fie");
  return v6;
}
// 170C: conditional instruction was optimized away because %var_C.4==1
// 1716: conditional instruction was optimized away because %var_C.4==1
// 1720: conditional instruction was optimized away because %var_C.4==1

//----- (0000000000001A2D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char *teehee()
{
  __int64 len; // [rsp+0h] [rbp-20h]

  len = sysconf(30);
  mprotect((void *)((unsigned __int64)expand & -len), len, 7);
  *(&loc_16D3 + 3) = 1;
  return (char *)&loc_16D3 + 3;
}
// 1A8C: write access to const memory at 16D6 has been detected

//----- (0000000000001A92) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rax
  void *v4; // rsp
  char v6[8]; // [rsp+8h] [rbp-80h] BYREF
  int i; // [rsp+10h] [rbp-78h]
  int n; // [rsp+14h] [rbp-74h]
  FILE *stream; // [rsp+18h] [rbp-70h]
  __int64 v10; // [rsp+20h] [rbp-68h]
  char *s; // [rsp+28h] [rbp-60h]
  _BYTE *v12; // [rsp+30h] [rbp-58h]
  _BYTE *v13; // [rsp+38h] [rbp-50h]
  void *ptr; // [rsp+40h] [rbp-48h]
  FILE *v15; // [rsp+48h] [rbp-40h]
  unsigned __int64 v16; // [rsp+50h] [rbp-38h]

  v16 = __readfsqword(0x28u);
  puts("\nMay Jupiter strike you down Caeser before you seize the treasury!! You will have to tear me apart");
  puts("for me to tell you the flag to unlock the Roman Treasury and fund your civil war. I, Lucius Caecilius");
  puts("Metellus, shall not let you pass until you get this password right. (or threaten to kill me-)\n");
  stream = fopen("palatinepackflag.txt", "r");
  fseek(stream, 0, 2);
  n = ftell(stream) + 1;
  fseek(stream, 0, 0);
  v10 = n - 1LL;
  v3 = 16 * ((n + 15LL) / 0x10uLL);
  while ( v6 != &v6[-(v3 & 0xFFFFFFFFFFFFF000LL)] )
    ;
  v4 = alloca(v3 & 0xFFF);
  if ( (v3 & 0xFFF) != 0 )
    *(_QWORD *)&v6[(v3 & 0xFFF) - 8] = *(_QWORD *)&v6[(v3 & 0xFFF) - 8];
  s = v6;
  fgets(v6, n, stream);
  flipBits((__int64)s, n);
  v12 = expand((__int64)s, n);
  v13 = expand((__int64)v12, 2 * n);
  ptr = expand((__int64)v13, 4 * n);
  anti_debug();
  for ( i = 0; i < 8 * n; ++i )
    putchar(*((unsigned __int8 *)ptr + i));
  putchar(10);
  v15 = fopen("flag.txt", "wb");
  fwrite(ptr, 1u, 8 * n, v15);
  fclose(v15);
  return 0;
}

//----- (0000000000001D0C) ----------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=65 queued=31 decompiled=31 lumina nreq=0 worse=0 better=0
// ALL OK, 31 function(s) have been successfully decompiled

```
So the program gives us a weird looking flag.txt after it runs, but that file is not the real flag. It’s some transformed/encrypted version of the flag. I looked at the code and basically the program messes with the original flag in two ways:
- It flips the bytes (like NOT and XOR)
- It expands the bytes three times, each time doubling the size

So to get back the actual flag I need to do the same thing but in reverse.

### Understanding what expand() does

expand() takes each byte and splits it into two bytes, mixing the upper nibble (top 4 bits) and the lower nibble (bottom 4 bits).
It also switches how it mixes them every time (so first byte is done one way, second byte is done another way, and so on).

Because the program calls expand() three times:

1st time: 1 → 2 bytes

2nd time: 2 → 4 bytes

3rd time: 4 → 8 bytes

So final flag file is 8× the original length.

To undo it, I must run a function that does the opposite (I called mine rx() for reverse expand).
Each rx() halves the size.

### Understanding flipBits()

Before the expanding happens, the program does flipBits() on every byte of the real flag.

flipBits alternates between two actions:

On byte 0 → do ~byte (NOT)

On byte 1 → do byte ^ key (XOR with key = 105)

On byte 2 → do NOT again

On byte 3 → do XOR again (key increases by 32 each time)

So to undo it:

If it's a NOT byte → I do NOT again

If it’s an XOR byte → I XOR with the same key again

Since XOR is symmetrical (XOR twice cancels out), it works nicely.

### Decoding the Base64

The flag file the binary made is binary data, so I need to base64 decode it safely:
```
base64 -D -i flag.txt.b64 -o flag.bin
```

Now flag.bin contains the actual encrypted bytes.

✔ Step 4: Running the Python Script

I wrote a small Python script with:

a function to reverse expand

a loop to reverse flipBits

print the result

Here’s the  script:
```
d=open("flag.bin","rb").read()

def rx(b):
    o=bytearray(len(b)//2)
    t=0
    for i in range(len(o)):
        x=b[2*i];y=b[2*i+1]
        o[i]=(x&15)|(y&240) if t==0 else (x&240)|(y&15)
        t=1-t
    return bytes(o)

a=rx(d)
a=rx(a)
a=rx(a)

o=bytearray(len(a))
t=0;k=105
for i in range(len(a)):
    if t==0:
        o[i]=(~a[i])&255
    else:
        o[i]=a[i]^k
        k=(k+32)&255
    t=1-t

print(o.decode("utf-8","ignore"))
```
## The Output
```
shaunak@Shaunaks-MacBook-Pro JoyDivision % base64 -i flag.txt -o flag.txt.b64

shaunak@Shaunaks-MacBook-Pro JoyDivision % base64 -D -i flag.txt.b64 -o flag.bin 

shaunak@Shaunaks-MacBook-Pro JoyDivision % python3 sol.py
sunshine{C3A5ER_CR055ED_TH3_RUB1C0N}
```
Running the script prints the flag:
```
sunshine{C3A5ER_CR055ED_TH3_RUB1C0N}
```


## Notes

- I didn’t need to understand every tiny bit of the C code — just the order of operations.

- Expand grows the data. Reverse expand shrinks it.

- FlipBits alternates NOT and XOR. Undo them in the same order.

- XOR is nice because doing XOR twice with the same value gives back the original.

- Base64 was important so the bytes don’t get corrupted.


#  Worthy Knight
First I decompile it
```
/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
// int printf(const char *format, ...);
// size_t strcspn(const char *s, const char *reject);
// int sprintf(char *s, const char *format, ...);
// size_t strlen(const char *s);
// const unsigned __int16 **__ctype_b_loc(void);
// int strcmp(const char *s1, const char *s2);
// int puts(const char *s);
// __int64 __fastcall MD5(_QWORD, _QWORD, _QWORD); weak
// char *fgets(char *s, int n, FILE *stream);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
FILE **sub_14C0();
__int64 sub_14F0();
FILE **sub_1530();
__int64 sub_1580();
void term_proc();
// int _cxa_finalize(void *);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
const char aTheAncientDrag[70] = "   The ancient dragon roars: \"Begone, unworthy!\"   \n           __,---/"; // idb
void *off_4058 = &off_4058; // idb
FILE *stdin; // idb
char byte_4068; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 40D8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (00000000000010D0) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  const unsigned __int16 *v3; // rsi
  char *v4; // rax
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // dx
  unsigned int v7; // ebp
  char *v9; // r12
  size_t v10; // rax
  char *v11; // rbp
  int v12; // edx
  char *v13; // rdi
  char v14[2]; // [rsp+Ch] [rbp-10Ch] BYREF
  char v15; // [rsp+Eh] [rbp-10Ah]
  char v16[16]; // [rsp+10h] [rbp-108h] BYREF
  char s1[32]; // [rsp+20h] [rbp-F8h] BYREF
  char v18; // [rsp+40h] [rbp-D8h] BYREF
  char s[16]; // [rsp+50h] [rbp-C8h] BYREF
  __int128 v20; // [rsp+60h] [rbp-B8h]
  __int128 v21; // [rsp+70h] [rbp-A8h]
  __int128 v22; // [rsp+80h] [rbp-98h]
  __int128 v23; // [rsp+90h] [rbp-88h]
  __int128 v24; // [rsp+A0h] [rbp-78h]
  __int128 v25; // [rsp+B0h] [rbp-68h]
  __int128 v26; // [rsp+C0h] [rbp-58h]
  unsigned __int64 v27; // [rsp+D8h] [rbp-40h]

  v27 = __readfsqword(0x28u);
  puts(
    "                       (Knight's Adventure)                \n"
    "\n"
    "         O                                              \n"
    "        <M>            .---.                            \n"
    "        /W\\           ( -.- )--------.                  \n"
    "   ^    \\|/            \\_o_/         )    ^             \n"
    "  /|\\    |     *      ~~~~~~~       /    /|\\            \n"
    "  / \\   / \\  /|\\                    /    / \\            \n"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
    "Welcome, traveler. A mighty dragon blocks the gate.\n"
    "Speak the secret incantation (10 runic letters) to continue.\n");
  *(_OWORD *)s = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  printf("Enter your incantation: ");
  if ( !fgets(s, 128, stdin) )
  {
    puts("\nSomething went awry. Fare thee well...");
    return 1;
  }
  s[strcspn(s, "\n")] = 0;
  if ( strlen(s) != 10 )
  {
    puts("\nScribe's note: The incantation must be exactly 10 runic symbols.");
    puts(aTheAncientDrag);
    return 1;
  }
  v3 = *__ctype_b_loc();
  v4 = s;
  do
  {
    v5 = v3[(unsigned __int8)*v4];
    if ( (v5 & 0x400) == 0 || (v6 = v3[(unsigned __int8)v4[1]], (v6 & 0x400) == 0) )
    {
      puts("\nThe runes fail to align. The incantation is impure.");
      puts(aTheAncientDrag);
      return 1;
    }
    if ( (v5 & 0x100) != 0 && (v6 & 0x100) != 0 || (v5 & 0x200) != 0 && (v6 & 0x200) != 0 )
    {
      puts("\nThe ancient seals do not resonate with your runes.");
      puts(aTheAncientDrag);
      return 1;
    }
    v4 += 2;
  }
  while ( v4 != &s[10] );
  if ( (s[0] ^ s[1]) != 36 )
  {
    puts("\nThe wards reject your Pair 1.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[1] != 106 )
  {
    puts("\nThe wards reject your Pair 1 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[3] ^ s[2]) != 56 )
  {
    puts("\nThe wards reject your Pair 2.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[3] != 83 )
  {
    puts("\nThe wards reject your Pair 2 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  v15 = 0;
  v9 = v16;
  *(_WORD *)v14 = __ROL2__(*(_WORD *)&s[4], 8);
  v10 = strlen(v14);
  v11 = s1;
  MD5(v14, v10, v16);
  do
  {
    v12 = (unsigned __int8)*v9;
    v13 = v11;
    v11 += 2;
    ++v9;
    sprintf(v13, "%02x", v12);
  }
  while ( &v18 != v11 );
  v18 = 0;
  v7 = strcmp(s1, "33a3192ba92b5a4803c9a9ed70ea5a9c");
  if ( v7 )
  {
    puts("\nThe dragon's eyes glow red... The final seal remains locked.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[7] ^ s[6]) != 56 )
  {
    puts("\nThe wards reject your Pair 4.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[7] != 97 )
  {
    puts("\nThe wards reject your Pair 4 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[8] ^ s[9]) != 32 )
  {
    puts("\nThe wards reject your Pair 5.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[9] != 105 )
  {
    puts("\nThe wards reject your Pair 5 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  printf(
    "\n%s\n",
    "   The kingdom's gates open, revealing the hidden realm...    \n"
    "                         ( (                                 \n"
    "                          \\ \\                                \n"
    "                     .--.  ) ) .--.                         \n"
    "                    (    )/_/ (    )                        \n"
    "                     '--'      '--'                         \n"
    "    \"Huzzah! Thy incantation is true. Onward, brave knight!\" \n");
  printf("The final scroll reveals your reward: KCTF{%s}\n\n", s);
  return v7;
}
// 10B0: using guessed type __int64 __fastcall MD5(_QWORD, _QWORD, _QWORD);

//----- (0000000000001490) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 149A: positive sp value 8 has been found
// 14A1: variable 'v3' is possibly undefined

//----- (00000000000014C0) ----------------------------------------------------
FILE **sub_14C0()
{
  return &stdin;
}

//----- (00000000000014F0) ----------------------------------------------------
__int64 sub_14F0()
{
  return 0;
}

//----- (0000000000001530) ----------------------------------------------------
FILE **sub_1530()
{
  FILE **result; // rax

  if ( !byte_4068 )
  {
    if ( &_cxa_finalize )
      _cxa_finalize(off_4058);
    result = sub_14C0();
    byte_4068 = 1;
  }
  return result;
}
// 4068: using guessed type char byte_4068;

//----- (0000000000001580) ----------------------------------------------------
// attributes: thunk
__int64 sub_1580()
{
  return sub_14F0();
}

//----- (000000000000158C) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=32 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled

```

I opened the code. It asks for a 10 letter password.
Then it checks each pair of 2 letters.

So the string is like:
```
s[0] s[1]  s[2] s[3]  s[4] s[5]  s[6] s[7]  s[8] s[9]
```

It checks 5 pairs.

### Pair 1 (s[0], s[1])

The code says:
``
(s[0] ^ s[1]) == 36
s[1] == 106 ('j')
``

So:
``
s[1] = 'j'
s[0] = 36 ^ 106 = 'N'
``

So first pair is:

**Nj**

### Pair 2 (s[2], s[3])

The code says:
```
(s[3] ^ s[2]) == 56
s[3] == 'S'
```

So:
```
s[3] = 'S'
s[2] = 56 ^ 'S' = 'k'
```

So second pair is:

**kS**

### Pair 3

This part was confusing but basically:

It takes s[5] + s[4]

Calculates MD5

Compares it to a fixed MD5 string.

So I brute-forced all combinations of letters (uppercase + lowercase).
Very small set, only 52×52 tries.
```
import hashlib
import string

t="33a3192ba92b5a4803c9a9ed70ea5a9c"
l=string.ascii_letters

for a in l:
    for b in l:
        if a.isupper()==b.isupper():
            continue
        x=(b+a).encode()
        if hashlib.md5(x).hexdigest()==t:
            print(a,b)
            exit()
```

The correct match was:
```
s[4] = 'f'
s[5] = 'T'
```

So third pair is:

***fT***

### Pair 4 (s[6], s[7])

The code says:
```
(s[7] ^ s[6]) == 56
s[7] == 'a'
```

So:
```
s[7] = 'a'
s[6] = 56 ^ 'a' = 'Y'
```

So fourth pair is:

**Ya**

### Pair 5 (s[8], s[9])

The code says:
```
(s[8] ^ s[9]) == 32
s[9] == 'i'
```

So:
```
s[9] = 'i'
s[8] = 32 ^ 'i' = 'I'
```

So last pair is:

**Ii**

## Final Incantation

Putting all pairs together:

**Nj kS fT Ya Ii**


So the final 10-letter string is:
**NjkSfTYaIi**

The program prints the flag:

**KCTF{NjkSfTYaIi}**
