# JoyDivision
First i decompile it
So the program gives us a weird looking flag.txt after it runs, but that file is not the real flag. It’s some transformed/encrypted version of the flag. I looked at the code and basically the program messes with the original flag in two ways:
- It flips the bytes (like NOT and XOR)
- It expands the bytes three times, each time doubling the size

So to get back the actual flag I need to do the same thing but in reverse.

### Understanding what expand() does

expand() takes each byte and splits it into two bytes, mixing the upper nibble (top 4 bits) and the lower nibble (bottom 4 bits).
It also switches how it mixes them every time (so first byte is done one way, second byte is done another way, and so on).

Because the program calls expand() three times:

1st time: 1 → 2 bytes

2nd time: 2 → 4 bytes

3rd time: 4 → 8 bytes

So final flag file is 8× the original length.

To undo it, I must run a function that does the opposite (I called mine rx() for reverse expand).
Each rx() halves the size.

### Understanding flipBits()

Before the expanding happens, the program does flipBits() on every byte of the real flag.

flipBits alternates between two actions:

On byte 0 → do ~byte (NOT)

On byte 1 → do byte ^ key (XOR with key = 105)

On byte 2 → do NOT again

On byte 3 → do XOR again (key increases by 32 each time)

So to undo it:

If it's a NOT byte → I do NOT again

If it’s an XOR byte → I XOR with the same key again

Since XOR is symmetrical (XOR twice cancels out), it works nicely.

### Decoding the Base64

The flag file the binary made is binary data, so I need to base64 decode it safely:
```
base64 -D -i flag.txt.b64 -o flag.bin
```

Now flag.bin contains the actual encrypted bytes.

✔ Step 4: Running the Python Script

I wrote a small Python script with:

a function to reverse expand

a loop to reverse flipBits

print the result

Here’s the  script:
```
d=open("flag.bin","rb").read()

def rx(b):
    o=bytearray(len(b)//2)
    t=0
    for i in range(len(o)):
        x=b[2*i];y=b[2*i+1]
        o[i]=(x&15)|(y&240) if t==0 else (x&240)|(y&15)
        t=1-t
    return bytes(o)

a=rx(d)
a=rx(a)
a=rx(a)

o=bytearray(len(a))
t=0;k=105
for i in range(len(a)):
    if t==0:
        o[i]=(~a[i])&255
    else:
        o[i]=a[i]^k
        k=(k+32)&255
    t=1-t

print(o.decode("utf-8","ignore"))
```
## The Output
```
shaunak@Shaunaks-MacBook-Pro JoyDivision % base64 -i flag.txt -o flag.txt.b64

shaunak@Shaunaks-MacBook-Pro JoyDivision % base64 -D -i flag.txt.b64 -o flag.bin 

shaunak@Shaunaks-MacBook-Pro JoyDivision % python3 sol.py
sunshine{C3A5ER_CR055ED_TH3_RUB1C0N}
```
Running the script prints the flag:
```
sunshine{C3A5ER_CR055ED_TH3_RUB1C0N}
```


## Notes

- I didn’t need to understand every tiny bit of the C code — just the order of operations.

- Expand grows the data. Reverse expand shrinks it.

- FlipBits alternates NOT and XOR. Undo them in the same order.

- XOR is nice because doing XOR twice with the same value gives back the original.

- Base64 was important so the bytes don’t get corrupted.


#  Worthy Knight
First I decompile it
```
/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
// int printf(const char *format, ...);
// size_t strcspn(const char *s, const char *reject);
// int sprintf(char *s, const char *format, ...);
// size_t strlen(const char *s);
// const unsigned __int16 **__ctype_b_loc(void);
// int strcmp(const char *s1, const char *s2);
// int puts(const char *s);
// __int64 __fastcall MD5(_QWORD, _QWORD, _QWORD); weak
// char *fgets(char *s, int n, FILE *stream);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
FILE **sub_14C0();
__int64 sub_14F0();
FILE **sub_1530();
__int64 sub_1580();
void term_proc();
// int _cxa_finalize(void *);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
const char aTheAncientDrag[70] = "   The ancient dragon roars: \"Begone, unworthy!\"   \n           __,---/"; // idb
void *off_4058 = &off_4058; // idb
FILE *stdin; // idb
char byte_4068; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 40D8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (00000000000010D0) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  const unsigned __int16 *v3; // rsi
  char *v4; // rax
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // dx
  unsigned int v7; // ebp
  char *v9; // r12
  size_t v10; // rax
  char *v11; // rbp
  int v12; // edx
  char *v13; // rdi
  char v14[2]; // [rsp+Ch] [rbp-10Ch] BYREF
  char v15; // [rsp+Eh] [rbp-10Ah]
  char v16[16]; // [rsp+10h] [rbp-108h] BYREF
  char s1[32]; // [rsp+20h] [rbp-F8h] BYREF
  char v18; // [rsp+40h] [rbp-D8h] BYREF
  char s[16]; // [rsp+50h] [rbp-C8h] BYREF
  __int128 v20; // [rsp+60h] [rbp-B8h]
  __int128 v21; // [rsp+70h] [rbp-A8h]
  __int128 v22; // [rsp+80h] [rbp-98h]
  __int128 v23; // [rsp+90h] [rbp-88h]
  __int128 v24; // [rsp+A0h] [rbp-78h]
  __int128 v25; // [rsp+B0h] [rbp-68h]
  __int128 v26; // [rsp+C0h] [rbp-58h]
  unsigned __int64 v27; // [rsp+D8h] [rbp-40h]

  v27 = __readfsqword(0x28u);
  puts(
    "                       (Knight's Adventure)                \n"
    "\n"
    "         O                                              \n"
    "        <M>            .---.                            \n"
    "        /W\\           ( -.- )--------.                  \n"
    "   ^    \\|/            \\_o_/         )    ^             \n"
    "  /|\\    |     *      ~~~~~~~       /    /|\\            \n"
    "  / \\   / \\  /|\\                    /    / \\            \n"
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
    "Welcome, traveler. A mighty dragon blocks the gate.\n"
    "Speak the secret incantation (10 runic letters) to continue.\n");
  *(_OWORD *)s = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  printf("Enter your incantation: ");
  if ( !fgets(s, 128, stdin) )
  {
    puts("\nSomething went awry. Fare thee well...");
    return 1;
  }
  s[strcspn(s, "\n")] = 0;
  if ( strlen(s) != 10 )
  {
    puts("\nScribe's note: The incantation must be exactly 10 runic symbols.");
    puts(aTheAncientDrag);
    return 1;
  }
  v3 = *__ctype_b_loc();
  v4 = s;
  do
  {
    v5 = v3[(unsigned __int8)*v4];
    if ( (v5 & 0x400) == 0 || (v6 = v3[(unsigned __int8)v4[1]], (v6 & 0x400) == 0) )
    {
      puts("\nThe runes fail to align. The incantation is impure.");
      puts(aTheAncientDrag);
      return 1;
    }
    if ( (v5 & 0x100) != 0 && (v6 & 0x100) != 0 || (v5 & 0x200) != 0 && (v6 & 0x200) != 0 )
    {
      puts("\nThe ancient seals do not resonate with your runes.");
      puts(aTheAncientDrag);
      return 1;
    }
    v4 += 2;
  }
  while ( v4 != &s[10] );
  if ( (s[0] ^ s[1]) != 36 )
  {
    puts("\nThe wards reject your Pair 1.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[1] != 106 )
  {
    puts("\nThe wards reject your Pair 1 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[3] ^ s[2]) != 56 )
  {
    puts("\nThe wards reject your Pair 2.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[3] != 83 )
  {
    puts("\nThe wards reject your Pair 2 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  v15 = 0;
  v9 = v16;
  *(_WORD *)v14 = __ROL2__(*(_WORD *)&s[4], 8);
  v10 = strlen(v14);
  v11 = s1;
  MD5(v14, v10, v16);
  do
  {
    v12 = (unsigned __int8)*v9;
    v13 = v11;
    v11 += 2;
    ++v9;
    sprintf(v13, "%02x", v12);
  }
  while ( &v18 != v11 );
  v18 = 0;
  v7 = strcmp(s1, "33a3192ba92b5a4803c9a9ed70ea5a9c");
  if ( v7 )
  {
    puts("\nThe dragon's eyes glow red... The final seal remains locked.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[7] ^ s[6]) != 56 )
  {
    puts("\nThe wards reject your Pair 4.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[7] != 97 )
  {
    puts("\nThe wards reject your Pair 4 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( (s[8] ^ s[9]) != 32 )
  {
    puts("\nThe wards reject your Pair 5.");
    puts(aTheAncientDrag);
    return 1;
  }
  if ( s[9] != 105 )
  {
    puts("\nThe wards reject your Pair 5 second char.");
    puts(aTheAncientDrag);
    return 1;
  }
  printf(
    "\n%s\n",
    "   The kingdom's gates open, revealing the hidden realm...    \n"
    "                         ( (                                 \n"
    "                          \\ \\                                \n"
    "                     .--.  ) ) .--.                         \n"
    "                    (    )/_/ (    )                        \n"
    "                     '--'      '--'                         \n"
    "    \"Huzzah! Thy incantation is true. Onward, brave knight!\" \n");
  printf("The final scroll reveals your reward: KCTF{%s}\n\n", s);
  return v7;
}
// 10B0: using guessed type __int64 __fastcall MD5(_QWORD, _QWORD, _QWORD);

//----- (0000000000001490) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 149A: positive sp value 8 has been found
// 14A1: variable 'v3' is possibly undefined

//----- (00000000000014C0) ----------------------------------------------------
FILE **sub_14C0()
{
  return &stdin;
}

//----- (00000000000014F0) ----------------------------------------------------
__int64 sub_14F0()
{
  return 0;
}

//----- (0000000000001530) ----------------------------------------------------
FILE **sub_1530()
{
  FILE **result; // rax

  if ( !byte_4068 )
  {
    if ( &_cxa_finalize )
      _cxa_finalize(off_4058);
    result = sub_14C0();
    byte_4068 = 1;
  }
  return result;
}
// 4068: using guessed type char byte_4068;

//----- (0000000000001580) ----------------------------------------------------
// attributes: thunk
__int64 sub_1580()
{
  return sub_14F0();
}

//----- (000000000000158C) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=32 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled

```

I opened the code. It asks for a 10 letter password.
Then it checks each pair of 2 letters.

So the string is like:
```
s[0] s[1]  s[2] s[3]  s[4] s[5]  s[6] s[7]  s[8] s[9]
```

It checks 5 pairs.

### Pair 1 (s[0], s[1])

The code says:
``
(s[0] ^ s[1]) == 36
s[1] == 106 ('j')
``

So:
``
s[1] = 'j'
s[0] = 36 ^ 106 = 'N'
``

So first pair is:

**Nj**

### Pair 2 (s[2], s[3])

The code says:
```
(s[3] ^ s[2]) == 56
s[3] == 'S'
```

So:
```
s[3] = 'S'
s[2] = 56 ^ 'S' = 'k'
```

So second pair is:

**kS**

### Pair 3

This part was confusing but basically:

It takes s[5] + s[4]

Calculates MD5

Compares it to a fixed MD5 string.

So I brute-forced all combinations of letters (uppercase + lowercase).
Very small set, only 52×52 tries.
```
import hashlib
import string

t="33a3192ba92b5a4803c9a9ed70ea5a9c"
l=string.ascii_letters

for a in l:
    for b in l:
        if a.isupper()==b.isupper():
            continue
        x=(b+a).encode()
        if hashlib.md5(x).hexdigest()==t:
            print(a,b)
            exit()
```

The correct match was:
```
s[4] = 'f'
s[5] = 'T'
```

So third pair is:

***fT***

### Pair 4 (s[6], s[7])

The code says:
```
(s[7] ^ s[6]) == 56
s[7] == 'a'
```

So:
```
s[7] = 'a'
s[6] = 56 ^ 'a' = 'Y'
```

So fourth pair is:

**Ya**

### Pair 5 (s[8], s[9])

The code says:
```
(s[8] ^ s[9]) == 32
s[9] == 'i'
```

So:
```
s[9] = 'i'
s[8] = 32 ^ 'i' = 'I'
```

So last pair is:

**Ii**

## Final Incantation

Putting all pairs together:

**Nj kS fT Ya Ii**


So the final 10-letter string is:
**NjkSfTYaIi**

The program prints the flag:

**KCTF{NjkSfTYaIi}**

# time
I opened the binary in ida, and read the pseudocode.

inside main(), i saw that the program is a number-guessing game that generates a random number using srand(time(0)) and then rand(), asks for a guess and then prints the secret number afterwards if the guess is wrong, else it prints the flag from flag.txt

the important part of the function looked like this:
```
if (v6 == v5)
{
    puts("You won. Guess was right! Here's your flag:");
    giveFlag();
}
else
{
    puts("Sorry. Try again, wrong guess!");
}
```

v6 is the random number generated using rand(), and v5 is the number the user enters.
the flag printing happens inside giveFlag(), which simply opens: **/home/h3/flag.txt**
and prints whatever is inside it.
so the logic is:
if I guess the random number, i get the flag
if not, i don't get the flag (wow surprise)

***but the number is based on the current time and changes every run, so brute-forcing it or predicting it manually is basically impossible***
then I looked at the assembly for the if statement. The important part was:
```
cmp [rbp+var_C], eax
jnz short loc_fail
```
since I wanted to always win, I decided to patch the binary by removing this conditional jump.
in IDA, I replaced jnz with two nops.
nop is basically a null instruction
```
cmp [rbp+var_C], eax
nop
nop
```
this means the program will always go to the “You won” branch and call giveFlag().
After patching the bytes and exporting the binary, I ran it again.
Now it instantly prints:
```
root@c05751c9661d:/home# ./time
Welcome to the number guessing game!
I'm thinking of a number. Can you guess it?
Guess right and you get a flag!
Enter your number: 123
Your guess was 123.
Looking for 1277730927.
You won. Guess was right! Here's your flag:
Flag file not found!  Contact an H3 admin for assistance.
root@c05751c9661d:/home# 
```
This confirms the patch worked because the win message appears every time.

## Notes
also i had to deal with a lot of compatibilty bs because im on a mac and the binary wont run on my machine or on my kali vm either, had to make a docker x86 environment to run and test the binaries
